(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MagicString = factory());
})(this, (function () { 'use strict';

	var BitSet = function BitSet(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	};

	BitSet.prototype.add = function add (n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	};

	BitSet.prototype.has = function has (n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	};

	var Chunk = function Chunk(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		// we make these non-enumerable, for sanity while debugging
		Object.defineProperties(this, {
			previous: { writable: true, value: null },
			next: { writable: true, value: null },
		});
	};

	Chunk.prototype.appendLeft = function appendLeft (content) {
		this.outro += content;
	};

	Chunk.prototype.appendRight = function appendRight (content) {
		this.intro = this.intro + content;
	};

	Chunk.prototype.clone = function clone () {
		var chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	};

	Chunk.prototype.contains = function contains (index) {
		return this.start < index && index < this.end;
	};

	Chunk.prototype.eachNext = function eachNext (fn) {
		var chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	};

	Chunk.prototype.eachPrevious = function eachPrevious (fn) {
		var chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	};

	Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	};

	Chunk.prototype.prependLeft = function prependLeft (content) {
		this.outro = content + this.outro;
	};

	Chunk.prototype.prependRight = function prependRight (content) {
		this.intro = content + this.intro;
	};

	Chunk.prototype.split = function split (index) {
		var sliceIndex = index - this.start;

		var originalBefore = this.original.slice(0, sliceIndex);
		var originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		var newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) { newChunk.next.previous = newChunk; }
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	};

	Chunk.prototype.toString = function toString () {
		return this.intro + this.content + this.outro;
	};

	Chunk.prototype.trimEnd = function trimEnd (rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }

		var trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) { return true; }
		}
	};

	Chunk.prototype.trimStart = function trimStart (rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }

		var trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.end - trimmed.length);
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) { return true; }
		}
	};

	var charToInteger = {};
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	for (var i = 0; i < chars.length; i++) {
	    charToInteger[chars.charCodeAt(i)] = i;
	}
	function encode(decoded) {
	    var sourceFileIndex = 0; // second field
	    var sourceCodeLine = 0; // third field
	    var sourceCodeColumn = 0; // fourth field
	    var nameIndex = 0; // fifth field
	    var mappings = '';
	    for (var i = 0; i < decoded.length; i++) {
	        var line = decoded[i];
	        if (i > 0)
	            mappings += ';';
	        if (line.length === 0)
	            continue;
	        var generatedCodeColumn = 0; // first field
	        var lineMappings = [];
	        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
	            var segment = line_1[_i];
	            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
	            generatedCodeColumn = segment[0];
	            if (segment.length > 1) {
	                segmentMappings +=
	                    encodeInteger(segment[1] - sourceFileIndex) +
	                        encodeInteger(segment[2] - sourceCodeLine) +
	                        encodeInteger(segment[3] - sourceCodeColumn);
	                sourceFileIndex = segment[1];
	                sourceCodeLine = segment[2];
	                sourceCodeColumn = segment[3];
	            }
	            if (segment.length === 5) {
	                segmentMappings += encodeInteger(segment[4] - nameIndex);
	                nameIndex = segment[4];
	            }
	            lineMappings.push(segmentMappings);
	        }
	        mappings += lineMappings.join(',');
	    }
	    return mappings;
	}
	function encodeInteger(num) {
	    var result = '';
	    num = num < 0 ? (-num << 1) | 1 : num << 1;
	    do {
	        var clamped = num & 31;
	        num >>>= 5;
	        if (num > 0) {
	            clamped |= 32;
	        }
	        result += chars[clamped];
	    } while (num > 0);
	    return result;
	}

	var btoa = function () {
		throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
	};
	if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
		btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
	} else if (typeof Buffer === 'function') {
		btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
	}

	var SourceMap = function SourceMap(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
	};

	SourceMap.prototype.toString = function toString () {
		return JSON.stringify(this);
	};

	SourceMap.prototype.toUrl = function toUrl () {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	};

	function guessIndent(code) {
		var lines = code.split('\n');

		var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
		var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

		if (tabbed.length === 0 && spaced.length === 0) {
			return null;
		}

		// More lines tabbed than spaced? Assume tabs, and
		// default to tabs in the case of a tie (or nothing
		// to go on)
		if (tabbed.length >= spaced.length) {
			return '\t';
		}

		// Otherwise, we need to guess the multiple
		var min = spaced.reduce(function (previous, current) {
			var numSpaces = /^ +/.exec(current)[0].length;
			return Math.min(numSpaces, previous);
		}, Infinity);

		return new Array(min + 1).join(' ');
	}

	function getRelativePath(from, to) {
		var fromParts = from.split(/[/\\]/);
		var toParts = to.split(/[/\\]/);

		fromParts.pop(); // get dirname

		while (fromParts[0] === toParts[0]) {
			fromParts.shift();
			toParts.shift();
		}

		if (fromParts.length) {
			var i = fromParts.length;
			while (i--) { fromParts[i] = '..'; }
		}

		return fromParts.concat(toParts).join('/');
	}

	var toString = Object.prototype.toString;

	function isObject(thing) {
		return toString.call(thing) === '[object Object]';
	}

	function getLocator(source) {
		var originalLines = source.split('\n');
		var lineOffsets = [];

		for (var i = 0, pos = 0; i < originalLines.length; i++) {
			lineOffsets.push(pos);
			pos += originalLines[i].length + 1;
		}

		return function locate(index) {
			var i = 0;
			var j = lineOffsets.length;
			while (i < j) {
				var m = (i + j) >> 1;
				if (index < lineOffsets[m]) {
					j = m;
				} else {
					i = m + 1;
				}
			}
			var line = i - 1;
			var column = index - lineOffsets[line];
			return { line: line, column: column };
		};
	}

	var Mappings = function Mappings(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	};

	Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
		}

		this.advance(content);
		this.pending = null;
	};

	Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
		var originalCharIndex = chunk.start;
		var first = true;

		while (originalCharIndex < chunk.end) {
			if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
				this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
			}

			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
			} else {
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIn