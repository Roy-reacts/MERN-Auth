const v4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/
const v4Size = 4
const v6Regex = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i
const v6Size = 16

export const v4 = {
  name: 'v4',
  size: v4Size,
  isFormat: ip => v4Regex.test(ip),
  encode (ip, buff, offset) {
    offset = ~~offset
    buff = buff || new Uint8Array(offset + v4Size)
    const max = ip.length
    let n = 0
    for (let i = 0; i < max;) {
      const c = ip.charCodeAt(i++)
      if (c === 46) { // "."
        buff[offset++] = n
        n = 0
      } else {
        n = n * 10 + (c - 48)
      }
    }
    buff[offset] = n
    return buff
  },
  decode (buff, offset) {
    offset = ~~offset
    return `${buff[offset++]}.${buff[offset++]}.${buff[offset++]}.${buff[offset]}`
  }
}

export const v6 = {
  name: 'v6',
  size: v6Size,
  isFormat: ip => ip.length > 0 && v6Regex.test(ip),
  encode (ip, buff, offset) {
    offset = ~~offset
    let end = offset + v6Size
    let fill = -1
    let hexN = 0
    let decN = 0
    let prevColon = true
    let useDec = false
    buff = buff || new Uint8Array(offset + v6Size)
    // Note: This algorithm needs to check if the offset
    // could exceed the buffer boundaries as it supports
    // non-standard compliant encodings that may go beyond
    // the boundary limits. if (offset < end) checks should
    // not be necessary...
    for (let i = 0; i < ip.length; i++) {
      let c = ip.charCodeAt(i)
      if (c === 58) { // :
        if (prevColon) {
          if (fill !== -1) {
            // Not Standard! (standard doesn't allow multiple ::)
            // We need to treat
            if (offset < end) buff[offset] = 0
            if (offset < end - 1) buff[offset + 1] = 0
            offset += 2
          } else if (offset < end) {
            // :: in the middle
            fill = offset
          }
        } else {
          // : ends the previous number
          if (useDec === true) {
            // Non-standard! (ipv4 should be at end only)
            // A ipv4 address should not be f